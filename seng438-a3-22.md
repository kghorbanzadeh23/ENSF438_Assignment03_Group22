**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report #3 – Code Coverage, Adequacy Criteria and Test Case Correlation**

| Group 22:      |     |
| -------------- | --- |
| Student Names: |Isabelle  |
|                |Kamand    |
|                |Spiro     |
|                |Dylan     |

(Note that some labs require individual reports while others require one report
for each group. Please see each lab document for details.)

# 1 Introduction

Text…

# 2 Manual data-flow coverage calculations for X and Y methods

## Method 1: DataUtilities.calculateColumnTotal
![alt text](image.png)

### Data flow graph

### Def-use sets per statement

| Line | Code                                                                 | DU (Definition-Use) |
|------|----------------------------------------------------------------------|---------------------|
| 1    | public static double calculateColumnTotal(Values2D data, int column) |def={data,column} c-use={} p-use={} |
| 2    | ParamChecks.nullNotPermitted(data, "data");                          |def={} c-use={data} p-use={} |
| 3    | double total = 0.0;                                                  |def={total} c-use={} p-use={} |
| 4    | int rowCount = data.getRowCount();                                   |def={rowCount} c-use={data} p-use={} |
| 5    | for (int r = 0; r < rowCount; r++)                                   |def={r} c-use={r} p-use={r, rowCount} |
| 6    | Number n = data.getValue(r, column);                                 |def={n} c-use={data,r,column} p-use={} |
| 7    | if (n != null)                                                       |def={} c-use={} p-use={n} |
| 8    | total += n.doubleValue();                                            |def={total} c-use={total,n} p-use={} |
| 9    | for (int r2 = 0; r2 > rowCount; r2++)                                |def={r2} c-use={r2} p-use={r2,rowCount} |
| 10   | Number n = data.getValue(r2, column);                                |def={n} c-use={data,r2,column} p-use={} |
| 11   | if (n != null)                                                       |def={} c-use={} p-use={n} |
| 12   | total += n.doubleValue();                                            |def={total} c-use={total,n} p-use={} |
| 13   | return total;                                                        |def={} c-use={total} p-use={} |


### All DU-pairs per variable
                                
| Variable | Def Line | Use Line          | DU Pair                                      |
|----------|----------|-------------------|----------------------------------------------|
| data     | 1        | 2, 4, 6, 10       | {1,2}, {1,4}, {1,6}, {1,10}                  |
| column   | 1        | 6, 10             | {1,6}, {1,10}                                |
| total    | 3, 8, 12 | 8, 12, 13         | {3,8}, {3,12}, {3,13}, {8,8}, {8,12}, {8,13}, {12,8}, {12,12}, {12,13} |
| rowCount | 4        | 5, 9              | {4,5}, {4,9}                                 |
| r        | 5        | 5, 6              | {5,5}, {5,6}                                 |
| n        | 6, 10    | 7, 8, 11, 12      | {6,7}, {6,8}, {6,11}, {6,12}, {10,7}, {10,8}, {10,11}, {10,12} |
| r2       | 9        | 11, 12            | {9,11}, {9,12}                               |


### Each test case show which pairs are covered

### Calculate the DU-Pair coverage.

## Method 2: Range.contains
![alt text](image-2.png)

###  Data flow graph

###  Def-use sets per statement

| Line | Code                                                                 | DU (Definition-Use) |
|------|----------------------------------------------------------------------|---------------------|
| 1    | public boolean contains(double value)                                | def={value} c-use={} p-use={} |
| 2    | if (value < this.lower)                                              | def={} c-use={} p-use={value, this.lower} |
| 3    | return false;                                                        | def={} c-use={} p-use={} |
| 4    | if (value > this.upper)                                              | def={} c-use={} p-use={value, this.upper} |
| 5    | return false;                                                        | def={} c-use={} p-use={} |
| 6    | return (value >= this.lower && value <= this.upper);                 | def={} c-use={value, this.lower, this.upper} p-use={} |

###  All DU-pairs per variable

| Variable | Def Line | Use Line          | DU Pair                                      |
|----------|----------|-------------------|----------------------------------------------|
| value    | 1        | 2, 4, 6           | {1,2}, {1,4}, {1,6}                          |
| this.lower | -      | 2, 6              | {-,2}, {-,6}                                 |
| this.upper | -      | 4, 6              | {-,4}, {-,6}                                 |

###  Each test case show which pairs are covered

### Calculate the DU-Pair coverage.

# 3 A detailed description of the testing strategy for the new unit test

Text…

# 4 A high level description of five selected test cases you have designed using coverage information, and how they have increased code coverage

Text…

# 5 A detailed report of the coverage achieved of each class and method (a screen shot from the code cover results in green and red color would suffice)

Text…

# 6 Pros and Cons of coverage tools used and Metrics you report

For our code coverage tool we chose to use EclEmma in Eclipse because it was the recommended tool as per the lab, as well as being very easy to integrate into our IDE, making it easy to use without much setup. It supports key coverage metrics like line, method, and branch coverage, which are sufficient for our project's needs. EclEmma provides real time feedback within the IDE, showing us which lines and branches are covered, which allows for immediate visibility and very easy analysis into the effectiveness of the tests we wrote. EclEmma does have some limitations, such as the lack of support for condition coverage (can be replaced with method coverage), which could have provided more detailed insights into the decision points in our code. Additionally, while the tool is lightweight and fast, it doesn't offer advanced customization or detailed reporting like some other tools do such as JaCoCo or Cobertura. Despite these drawbacks, we decided on using EclEmma due to its simplicity, ease of integration for Eclipse, and the fact that it met the basic coverage requirements for our project.

The suggested metrics to report from the lab were statement, branch, and condition coverages. Since we are using EclEmma, which does not support condition coverage, we opted to replace it with method coverage. This decision was made because method coverage still provides valuable insights into the effectiveness of testing by ensuring that each method in the code has been executed. While condition coverage maye have offered us a deeper analysis into decision points, method coverage serves as a practical substitution.

Pros: Simple integration with Eclipse, supports required coverage metrics (line, method (condition substitute), branch), gives real time in IDE feedback, lightweight and fast, free and open-source.
Cons: Lacks condition coverage, limited customization and reporting options, not as actively updated or feature-rich as other coverage tools like JaCoCo, only suitable for Java projects.


# 7 A comparison on the advantages and disadvantages of requirements-based test generation and coverage-based test generation.

Text…

# 8 A discussion on how the team work/effort was divided and managed

Text…

# 9 Any difficulties encountered, challenges overcome, and lessons learned from performing the lab

Text…

# 10 Comments/feedback on the lab itself

Text…
